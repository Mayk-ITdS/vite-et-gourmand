Create table users(
user_id bigint Generate
)


Create table roles(role_id INT GENERATED by default as identity PRIMARY KEY,
					role_name varchar(20) not null,
					COnstraint uk_roles_name Unique(role_name),
					Constraint ck_roles_name check(role_name in ('user','admin','employee','jury'))
					);							


Create table user_roles(user_id int not null references users(user_id) ON delete cascade,
						role_id int not null references roles(role_id) ON DELETE CASCADE,
						PRIMARY KEY(user_id,role_id)
						);
						
Create table if not exists menus(
menu_id int GENERATED by default as IDENTITY primary key,
menu_name varchar(20) not null,
prix_unitaire numeric(10,2) not null,
menu_theme varchar(55) not null,
description TEXT not null,
diet_type varchar(20) not null constraint ck_diet_type check(diet_type in ('Vegetarien', 'Vegan', 'Classique')),
min_persons int not null,
quantity_in_stock int not null,
min_preparation_time time not null
);

Create table if not exists themes(
theme_id int Generated by default as identity primary key,
theme_name varchar(55) not null UNIQUE
);

Create table if not exists menu_themes(
menu_id int references menus(menu_id),
theme_id int references themes(theme_id),
Primary key (menu_id,theme_id)
);

create table if not exists menu_items(
item_id int Generated by default as identity primary key,
item_name varchar(30) not null,
item_type varchar(30) not null,
no_persons int not null,
served_between_start time not null,
served_between_end time not null,
is_active bool not null,
diet_type varchar(20) not null constraint ck_diet_type check(diet_type in ('Vegetarien', 'Vegan', 'Classique')),
min_preparation_time interval not null,
in_stock bigint not null
);

create table if not exists menu_items_menus(
item_id int references menu_items(item_id),
menu_id int references menus(menu_id),
quantity int not null,
Primary key(menu_id,item_id)
);
Create table if not exists products(
product_id int generated by default as identity primary key, 
product_name varchar(50) not null,
diet_type varchar(20) not null constraint ck_diet_type check(diet_type in ('Vegetarien', 'Vegan', 'Classique')),
product_type varchar(20) not null,
price_unit decimal not null,
producer_name varchar(50) not null,
delivery_status varchar(20) not null constraint ck_delivery_status check(delivery_status in('arrived','delayed','departed','ordered','pending')),
arrival_date date not null constraint ck_arrival_date check(arrival_date <= CURRENT_TIMESTAMP),
expiration_date date not null constraint ck_expiration_date check(expiration_date >= CURRENT_DATE + 7),
in_stock numeric(8,2) not null,
unit varchar(30) not null constraint ck_product_unit check(unit in('kg','g','l','ml','szt'))
);

Create table if not exists products_to_items(
product_id int not null references products(product_id),
item_id int not null references menu_items(item_id),
quantity numeric(8,2),
primary key (product_id, item_id)
);

Create table if not exists products_ingredients(
product_id bigint not null references products(product_id),
ingredient_name varchar(50),
ingredient_quantity numeric not null,
ingredient_unit varchar(10) not null constraint ck_products_ingredients_unit CHECK (ingredient_unit IN ('kg','g','l','ml','szt'))
primary key(product_id,ingredient_name,ingredient_unit)
);

Create table if not exists reservations(
res_id int GENERATED BY DEFAULT as IDENTITY PRIMARY KEY,
user_id int not null references users(user_id),
no_persons int not null,
event_adress TEXT not null,
event_name TEXT,
date_res_made date not null,
date_res_for date not null,
res_status varchar(20) not null,
client_preferences TEXT,
equipement_loaned bool not null,
equipement_returned bool not null,
total_price decimal not null
);

DROP TABLE IF EXISTS reservation_menus;
Create table if not exists reservation_menus(
res_id int not null references reservations(res_id),
menu_id int not null references menus(menu_id),
unit_price_snapshot decimal not null,
quantity int not null,
notes TEXT,
primary key (res_id, menu_id)
);


CREATE INDEX idx_products_raw_name_unit_arrival
ON products (product_name, unit, arrival_date)
WHERE product_type = 'raw';

CREATE OR REPLACE FUNCTION trig_normalize_products()
RETURNS TRIGGER 
LANGUAGE plpgsql
AS $$
BEGIN 
    NEW.product_name := lower(btrim(NEW.product_name));
    NEW.unit := lower(btrim(NEW.unit));
    RETURN NEW;
END;
$$;

CREATE OR REPLACE FUNCTION trig_normalize_ingredients()
RETURNS TRIGGER 
LANGUAGE plpgsql
AS $$
BEGIN 
    NEW.ingredient_name := lower(btrim(NEW.ingredient_name));
    NEW.ingredient_unit := lower(btrim(NEW.ingredient_unit));
    RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS lower_on_insert_products ON products;
CREATE TRIGGER lower_on_insert_products
BEFORE INSERT OR UPDATE OF product_name,unit on products
FOR EACH ROW 
EXECUTE FUNCTION trig_normalize_products();

DROP TRIGGER IF EXISTS lower_on_insert_ingredients ON products_ingredients;
CREATE TRIGGER lower_on_insert_ingredients
BEFORE INSERT OR UPDATE OF ingredient_name,ingredient_unit on products_ingredients
FOR EACH ROW 
EXECUTE FUNCTION trig_normalize_ingredients();

CREATE OR REPLACE FUNCTION public.ingest_stock(mode text, payload jsonb)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, pg_temp
AS $$
DECLARE
  v_product_lot_id bigint;
  v_raw_lot_id bigint;
  v_raw_base_id bigint;
  v_raw_base_name varchar(50);
  v_semi_or_finish_base_id bigint;
  v_created_lots bigint[] := '{}';
  v_links_created int := 0;
  d record;
  i record;
BEGIN
  IF mode NOT IN ('lineage','synthesis') THEN
    RAISE EXCEPTION 'Invalid mode: %', mode;
  END IF;
  IF mode = 'lineage' THEN
    IF NOT (payload ? 'raw_deliveries')
    OR jsonb_typeof(payload->'raw_deliveries') <> 'array'
        THEN
            RAISE EXCEPTION 'payload.raw_deliveries must be a JSON array';
    END IF;

    FOR d IN
        Select * from jsonb_to_recordset(payload -> 'raw_deliveries') AS d(product_name varchar(50),
        product_type varchar(20),
        buy_price_lot numeric(10,2),
        lot_quantity numeric(10,2),
        diet_type varchar(20),
        producer_name varchar(50),
        arrival_date date,
        expiration_date date,
        unit varchar(30))
    LOOP
        IF d.product_type <> 'raw' THEN
                    RAISE EXCEPTION 'lineage accepts only raw deliveries, got: %', d.product_type;
        END IF;
        INSERT INTO products(product_name,
         product_type,
         buy_price_lot,
         lot_quantity, 
         diet_type, 
         producer_name, 
         arrival_date, 
         expiration_date, 
         delivery_status, 
         in_stock,unit) VALUES (
            d.product_name, 
            d.product_type, 
            d.buy_price_lot, 
            d.lot_quantity, 
            d.diet_type, 
            d.producer_name, 
            d.arrival_date, 
            d.expiration_date, 
            'arrived', 
            d.lot_quantity, 
            d.unit)
            RETURNING product_id into v_raw_lot_id;

        INSERT INTO products_ingredients(product_id, 
        d.product_name, 
        ingredient_quantity, 
        ingredient_unit) VALUES (
            v_raw_lot_id, 
            v_raw_base_name, 
            1, 
            d.unit);

        v_created_lots := array_append(v_created_lots,v_raw_lot_id);
    END LOOP;   
   
    RETURN jsonb_build_object(
      'mode', mode,
      'created_lot_ids', v_created_lots,
      'links_created', v_links_created
    );
  END IF;

  IF mode = 'synthesis' THEN

    IF NOT (payload ? 'semi_finished_deliveries')
    OR jsonb_typeof(payload->'semi_finished_deliveries') <> 'array'
        THEN
            RAISE EXCEPTION 'payload.semi_finished_deliveries must be a JSON array';
    END IF;
    FOR d IN
        Select * from jsonb_to_recordset(payload -> 'semi_finished_deliveries') AS d(
        product_name varchar(50),
        product_type varchar(20),
        buy_price_lot numeric(10,2),
        lot_quantity numeric(10,2),
        diet_type varchar(20),
        producer_name varchar(50),
        arrival_date date,
        expiration_date date,
        unit varchar(30),
        ingredients jsonb)
    LOOP
        IF d.product_type not in ('semi','finished') THEN
            RAISE EXCEPTION 'synthesis accepts only semi or finished deliveries, got: %', d.product_type;
        END IF;
        INSERT INTO products(
            product_name,
            product_type,
            buy_price_lot,
            lot_quantity,
            diet_type,
            producer_name,
            arrival_date,
            expiration_date,
            delivery_status,
            in_stock,
            unit) VALUES (
                d.product_name,
                d.product_type,
                d.buy_price_lot,
                d.lot_quantity,
                d.diet_type,
                d.producer_name,
                d.arrival_date,
                d.expiration_date,
                'arrived',
                d.lot_quantity,
                d.unit)
        RETURNING product_id into v_product_lot_id;
        FOR i IN 
            Select * from jsonb_to_recordset(d.ingredients) as i(
                ingredient_name varchar(50),
                diet_type varchar(20),
                calories numeric(10,2), 
                quantity numeric(10,2), 
                unit varchar(20))
        LOOP
            INSERT INTO products_ingredients(
                product_id, 
                ingredient_name, 
                ingredient_quantity, 
                ingredient_unit) VALUES (
                    v_product_lot_id, 
                    i.ingredient_name, 
                    i.quantity, 
                    i.unit)
            ON CONFLICT (product_id, ingredient_name, ingredient_unit) 
            DO UPDATE SET ingredient_quantity = EXCLUDED.ingredient_quantity;
        END LOOP;
        v_created_lots := array_append(v_created_lots,v_product_lot_id);
    END LOOP;
    
    RETURN jsonb_build_object(
      'mode', mode,
      'created_product_lot_id', v_product_lot_id,
      'links_created', v_links_created
    );
  END IF;

  RAISE EXCEPTION 'Unexpected flow';
END;
$$;

DROP trigger if exists user_hash_pass_trigger ON users;
Create Trigger user_hash_pass_trigger 
Before INsert or UPdate of password_hash on users
FOR EACH ROW
EXECUTE function users_hash_password();