Drop schema public cascade;
Create schema public;

CREATE TYPE diet_enum AS ENUM ('Vegetarien','Vegan','Classique');
CREATE TYPE product_type_enum AS ENUM ('raw','semi','finished');
CREATE TYPE delivery_status_enum AS ENUM ('arrived','delayed','departed','ordered','pending');
CREATE TYPE item_type_enum AS ENUM ('starter','main','dessert','drink','custom');
CREATE TYPE reservation_status_enum AS ENUM ('pending','confirmed','cancelled','completed');
CREATE EXTENSION IF NOT EXISTS citext;

Create table users(
user_id bigint Generated by default as IDENTITY PRIMARY KEY,
user_first_name varchar(30) not null,
user_last_name varchar(30) not null,
user_email citext not null UNIQUE,
password_hash varchar(255) not null,
mobile_number varchar(20) not null,
city varchar(55) not null,
street varchar(55) not null,
house_number int not null,
zip_code varchar(5) not null,
country varchar(30) not null,
is_active boolean not null DEFAULT true,
desactivated_at timestamp
);

Create table roles(
role_id INT GENERATED by default as identity PRIMARY KEY,
role_name varchar(20) not null,
COnstraint uk_roles_name Unique(role_name),
Constraint ck_roles_name check(role_name in ('user','admin','employee','jury'))
);	

INSERT INTO roles(role_name)
VALUES 
  ('user'),
  ('admin'),
  ('employee'),
  ('jury')
ON CONFLICT (role_name) DO NOTHING;


Create table user_roles(
user_id bigint not null references users(user_id) ON delete cascade,
role_id int not null references roles(role_id) ON DELETE CASCADE,
PRIMARY KEY(user_id,role_id)
);
					
Create table if not exists menus(
menu_id bigint GENERATED by default as IDENTITY primary key,
menu_code TEXT not null UNIQUE,
menu_name TEXT not null,
prix_unitaire numeric(10,2) not null,
description TEXT not null,
diet_type diet_enum not null, 
min_persons int not null,
order_lead_time interval not null,
quantity_in_stock bigint not null,
min_preparation_time interval not null,
image_url TEXT not null,
images TEXT[] not null DEFAULT '{}'
);

Create table administration(
admin_id int Generated by default as identity primary key,
admin_name TEXT not null,
admin_email citext not null unique,
admin_password varchar(255) not null,
role_id int not null
);
-- Admin creation --------------------
ALTER TABLE administration
ADD CONSTRAINT fk_admin_role
FOREIGN KEY (role_id)
REFERENCES roles(role_id);

CREATE EXTENSION IF NOT EXISTS pgcrypto;

INSERT INTO administration (
  admin_name,
  admin_email,
  admin_password,
  role_id
)
VALUES (
  'Michal',
  'studi@admin.fr',
  crypt('molto87bene', gen_salt('bf', 10)),
  3
);
---------------------------------------



Create table if not exists themes(
theme_id int Generated by default as identity primary key,
theme_name varchar(55) not null UNIQUE
);

INSERT INTO themes (theme_name)
SELECT unnest(ARRAY[
  'Tradition Française',
  'Haute Sélection',
  'Garden Party',
  'Vernissage',
  'Dîner Privé',
  'Anniversaire Élégant',
  'Événement Entreprise',
  'Soirée Romantique'
])
ON CONFLICT (theme_name) DO NOTHING;

Create table if not exists menu_themes(
menu_id bigint not null references menus(menu_id) on delete Cascade,
theme_id int not null references themes(theme_id) on delete CASCADE,
Primary key (menu_id,theme_id)
);

create table if not exists menu_items(
item_id bigint Generated by default as identity primary key,
item_code varchar(255) not null UNIQUE,
item_name text not null,
item_type item_type_enum not null,
min_persons int not null,
is_active bool not null,
served_window TEXT,
diet_type diet_enum not null, 
min_preparation_time interval not null,
in_stock bigint,
image_url text not null
);

create table if not exists menu_items_menus(
item_id bigint not null references menu_items(item_id) on delete CASCADE ,
menu_id bigint not null references menus(menu_id) on delete CASCADE,
quantity bigint not null,
Primary key(menu_id,item_id)
);

Create table if not exists products(
product_id bigint generated by default as identity primary key, 
product_name varchar(50) not null,
diet_type diet_enum not null, 
product_type product_type_enum not null, 
price_lot numeric(10,2) not null,
producer_name varchar(50) not null,
lot_quantity BIGINT not null,
delivery_status delivery_status_enum not null, 
arrival_date date not null, 
expiration_date date not null, 
in_stock numeric(8,2) not null,
unit varchar(30) not null, 
constraint ck_arrival_date check(arrival_date <= CURRENT_DATE),
constraint ck_expiration_date check(expiration_date >= CURRENT_DATE + 7),
constraint ck_product_unit check(unit in('kg','g','l','ml','szt'))
);

Create table if not exists products_to_items(
product_id bigint not null references products(product_id),
item_id bigint not null references menu_items(item_id),
quantity numeric(8,2) not null,
primary key (product_id, item_id)
);

Create table if not exists products_ingredients(
product_id bigint not null references products(product_id),
ingredient_name varchar(50) not null,
ingredient_quantity numeric(8,2) not null,
diet_type diet_enum not null, 
calories numeric(8,2) not null,
ingredient_unit varchar(10) not null, 
primary key(product_id,ingredient_name,ingredient_unit),
constraint ck_products_ingredients_unit CHECK (ingredient_unit IN ('kg','g','l','ml','lp'))
);

Create table if not exists reservations(
res_id bigint GENERATED BY DEFAULT as IDENTITY PRIMARY KEY,
user_id bigint not null references users(user_id),
no_persons int not null,
event_adress TEXT not null,
event_name TEXT,
date_res_made date not null,
event_date date not null,
res_status reservation_status_enum not null,
client_preferences TEXT,
equipement_loaned bool,
equipement_returned bool,
total_price numeric(10,2) not null
);

Create table if not exists reservation_menus(
res_id bigint not null references reservations(res_id),
menu_id bigint not null references menus(menu_id),
unit_price_snapshot numeric(10,2) not null,
quantity bigint not null,
notes TEXT,
primary key (res_id, menu_id)
);
CREATE TABLE order_status_history (
    history_id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    res_id bigint REFERENCES reservations(res_id) ON DELETE CASCADE,
    status reservation_status_enum NOT NULL,
    changed_at timestamp NOT NULL DEFAULT now(),
    changed_by bigint REFERENCES users(user_id)
);
CREATE INDEX idx_menu_items_diet_type ON menu_items(diet_type);
CREATE INDEX idx_menu_items_item_type ON menu_items(item_type);
CREATE INDEX idx_menu_items_name ON menu_items(item_name);
CREATE INDEX IF NOT EXISTS idx_menus_diet_type ON menus (diet_type);
CREATE INDEX IF NOT EXISTS idx_menus_stock ON menus (quantity_in_stock);
CREATE INDEX IF NOT EXISTS idx_menus_lead_time ON menus (order_lead_time);

-- menu_items_menus: PK(menu_id, item_id) już indeksuje po menu_id
CREATE INDEX IF NOT EXISTS idx_menu_items_menus_item_id
  ON menu_items_menus (item_id);
-- menu_themes: PK(menu_id, theme_id) już indeksuje po menu_id
CREATE INDEX IF NOT EXISTS idx_menu_themes_theme_id
  ON menu_themes (theme_id);
-- products_to_items: PK(product_id, item_id) już indeksuje po product_id
CREATE INDEX IF NOT EXISTS idx_products_to_items_item_id
  ON products_to_items (item_id);
-- reservation_menus: PK(res_id, menu_id) już indeksuje po res_id
CREATE INDEX IF NOT EXISTS idx_reservation_menus_menu_id
  ON reservation_menus (menu_id);
-- reservations: często "moje rezerwacje" po user_id
CREATE INDEX IF NOT EXISTS idx_reservations_user_id
  ON reservations (user_id);
CREATE INDEX idx_products_raw_name_unit_arrival
ON products (product_name, unit, arrival_date)
WHERE product_type = 'raw';

CREATE OR REPLACE FUNCTION trig_normalize_products()
RETURNS TRIGGER 
LANGUAGE plpgsql
AS $$
BEGIN 
    NEW.product_name := lower(btrim(NEW.product_name));
    NEW.unit := lower(btrim(NEW.unit));
    RETURN NEW;
END;
$$;

CREATE OR REPLACE FUNCTION trig_normalize_ingredients()
RETURNS TRIGGER 
LANGUAGE plpgsql
AS $$
BEGIN 
    NEW.ingredient_name := lower(btrim(NEW.ingredient_name));
    NEW.ingredient_unit := lower(btrim(NEW.ingredient_unit));
    RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS lower_on_insert_products ON products;
CREATE TRIGGER lower_on_insert_products
BEFORE INSERT OR UPDATE OF product_name,unit on products
FOR EACH ROW 
EXECUTE FUNCTION trig_normalize_products();

DROP TRIGGER IF EXISTS lower_on_insert_ingredients ON products_ingredients;
CREATE TRIGGER lower_on_insert_ingredients
BEFORE INSERT OR UPDATE OF ingredient_name,ingredient_unit on products_ingredients
FOR EACH ROW 
EXECUTE FUNCTION trig_normalize_ingredients();

CREATE OR REPLACE FUNCTION public.ingest_stock(mode text, payload jsonb)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, pg_temp
AS $$
DECLARE
  v_product_lot_id bigint;
  v_raw_lot_id bigint;
  v_created_lots bigint[] := '{}';
  v_links_created int := 0;
  d record;
  i record;
BEGIN
  IF mode NOT IN ('lineage','synthesis') THEN
    RAISE EXCEPTION 'Invalid mode: %', mode;
  END IF;
  IF mode = 'lineage' THEN
    IF NOT (payload ? 'raw_deliveries')
    OR jsonb_typeof(payload->'raw_deliveries') <> 'array'
        THEN
            RAISE EXCEPTION 'payload.raw_deliveries must be a JSON array';
    END IF;

    FOR d IN
        Select * from jsonb_to_recordset(payload -> 'raw_deliveries') AS d(product_name varchar(50),
        product_type product_type_enum,
        diet_type diet_enum,
		calories numeric(8,2),
		price_lot numeric(10,2),
		lot_quantity BIGINT,
        producer_name varchar(50),
        arrival_date date,
        expiration_date date,
		in_stock numeric(8,2),
        unit varchar(30)
		)
    LOOP
        IF d.product_type <> 'raw' THEN
                    RAISE EXCEPTION 'lineage accepts only raw deliveries, got: %', d.product_type;
        END IF;
        INSERT INTO products(product_name,
		product_type,
         price_lot,
         lot_quantity, 
         diet_type,
         producer_name, 
         arrival_date, 
         expiration_date, 
         delivery_status, 
         in_stock,unit) VALUES (
            d.product_name, 
            d.product_type, 
            d.price_lot, 
            d.lot_quantity, 
            d.diet_type, 
            d.producer_name, 
            d.arrival_date, 
            d.expiration_date, 
            'arrived', 
            d.lot_quantity, 
            d.unit)
            RETURNING product_id into v_raw_lot_id;

        INSERT INTO products_ingredients(product_id, 
        ingredient_name, 
        ingredient_quantity, 
		diet_type,
		calories,
        ingredient_unit) VALUES (
            v_raw_lot_id, 
            d.product_name,
			1,
			d.diet_type,
			d.calories, 
            d.unit);

        v_created_lots := array_append(v_created_lots,v_raw_lot_id);
    END LOOP;   
   
    RETURN jsonb_build_object(
      'mode', mode,
      'created_lot_ids', v_created_lots,
      'links_created', v_links_created
    );
  END IF;

  IF mode = 'synthesis' THEN

    IF NOT (payload ? 'semi_finished_deliveries')
    OR jsonb_typeof(payload->'semi_finished_deliveries') <> 'array'
        THEN
            RAISE EXCEPTION 'payload.semi_finished_deliveries must be a JSON array';
    END IF;
    FOR d IN
        Select * from jsonb_to_recordset(payload -> 'semi_finished_deliveries') AS d(
        product_name varchar(50),
        product_type product_type_enum,
        price_lot numeric(10,2),
        lot_quantity numeric(10,2),
        diet_type diet_enum,
        producer_name varchar(50),
        arrival_date date,
        expiration_date date,
        unit varchar(30),
        ingredients jsonb)
    LOOP
        IF d.product_type not in ('semi','finished') THEN
            RAISE EXCEPTION 'synthesis accepts only semi or finished deliveries, got: %', d.product_type;
        END IF;
        INSERT INTO products(
            product_name,
            product_type,
            price_lot,
            lot_quantity,
            diet_type,
            producer_name,
            arrival_date,
            expiration_date,
            delivery_status,
            in_stock,
            unit) VALUES (
                d.product_name,
                d.product_type,
                d.price_lot,
                d.lot_quantity,
                d.diet_type,
                d.producer_name,
                d.arrival_date,
                d.expiration_date,
                'arrived',
				d.lot_quantity,
                d.unit)
        RETURNING product_id into v_product_lot_id;
        FOR i IN 
            Select * from jsonb_to_recordset(d.ingredients) as i(
                ingredient_name varchar(50),
                diet_type diet_enum,
                calories numeric(10,2), 
                quantity numeric(10,2), 
                unit varchar(20))
        LOOP
            INSERT INTO products_ingredients(
                product_id, 
                ingredient_name,
				diet_type,
				calories,
                ingredient_quantity, 
                ingredient_unit) VALUES (
                    v_product_lot_id, 
                    i.ingredient_name,
					i.diet_type,
					i.calories,
                    i.quantity, 
                    i.unit)
            ON CONFLICT (product_id, ingredient_name, ingredient_unit) 
            DO UPDATE SET ingredient_quantity = EXCLUDED.ingredient_quantity;
        END LOOP;
        v_created_lots := array_append(v_created_lots,v_product_lot_id);
    END LOOP;
    
    RETURN jsonb_build_object(
      'mode', mode,
      'created_product_lot_id', v_product_lot_id,
      'links_created', v_links_created
    );
  END IF;

  RAISE EXCEPTION 'Unexpected flow';
END;
$$;

Create or replace function public.insert_new_user(mode TEXT, payload jsonb)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, pg_temp
AS $$
DECLARE
v_user_id bigint;
v_role_id int; 
v_role_name varchar(20); 
    Begin
        IF mode <> 'authClient' THEN
            RAISE EXCEPTION 'Invalid mode: %', mode;
        END IF;
        IF mode = 'authClient' THEN
            IF jsonb_typeof(payload) <> 'object' THEN
                RAISE EXCEPTION 'Payload must be JSON object';
            END IF;
        BEGIN   
            INSERT INTO users(
                user_first_name,
                user_last_name,
                user_email,
                password_hash,
                mobile_number,
                city,
                street,
                house_number,
                zip_code,
                country
            )
            VALUES (
                payload->>'user_first_name',
                payload->>'user_last_name',
                lower(btrim(payload->>'user_email')),
                payload->>'password_hash',
                payload->>'mobile_number',
                payload->>'city',
                payload->>'street',
                (payload->>'house_number')::int,
                payload->>'zip_code',
                payload->>'country'
                )
            RETURNING user_id INTO v_user_id;

        EXCEPTION
            WHEN unique_violation THEN
                RAISE EXCEPTION 'Email already exists';   
        END;
            v_role_name := 'user';
            Select role_id into v_role_id 
            FROM roles
            Where role_name = 'user' 
            limit 1;
            IF v_role_id IS NULL THEN
                RAISE EXCEPTION 'Role user not found. Seed roles first.';
            END IF;
            INSERT INTO user_roles(
                user_id,
                role_id) Values (
                    v_user_id,
                    v_role_id
                    );
                                                    
            RETURN jsonb_build_object(
            'mode',mode,
            'user_id',v_user_id,
            'role',v_role_name
            );
	    END IF;    
        RAISE EXCEPTION 'Unexpected flow';
    END;
$$;